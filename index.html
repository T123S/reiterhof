<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Pferde-Simulator - High Detail</title>
    <!-- Reverted to r128 for better stability in this environment -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; background: #87ceeb; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #config-panel {
            pointer-events: auto;
            position: absolute;
            top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            max-width: 280px;
            z-index: 10;
        }

        h2 { margin: 0 0 10px 0; color: #2c3e50; font-size: 1.2rem; }
        .row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; align-items: center; }
        input[type="color"] { border: none; width: 40px; height: 30px; cursor: pointer; background: none; padding: 0; }
        
        button.start-btn {
            width: 100%; padding: 10px; background: #27ae60; color: white; 
            border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-top: 10px;
            font-size: 1rem;
        }
        button.start-btn:hover { background: #219150; }

        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 10px 25px;
            border-radius: 20px; font-weight: bold; font-size: 16px;
            display: none; z-index: 5;
        }

        #controls-hint {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.6); color: white; padding: 15px;
            border-radius: 8px; font-size: 14px; line-height: 1.6;
            z-index: 5;
        }

        #minimap-container {
            position: absolute; top: 20px; right: 20px;
            width: 200px; height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 4px solid #fff;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 5;
        }
        #minimap { width: 100%; height: 100%; display: block; }

        #bubble {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 15px 30px; border-radius: 50px;
            border: 3px solid #333; font-weight: bold; font-size: 20px;
            display: none; z-index: 20;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
        }

        #feeding-modal {
            pointer-events: auto; display: none;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; padding: 25px; border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5); text-align: center; width: 300px;
            z-index: 30;
        }
        .food-btn {
            background: #f0f0f0; border: 2px solid #ddd; padding: 10px; margin: 5px;
            border-radius: 8px; cursor: pointer; font-size: 24px; transition: 0.2s;
        }
        .food-btn:hover { background: #e0e0e0; transform: scale(1.1); }
        #food-request { font-size: 40px; margin: 10px 0; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="config-panel">
        <h2>Pferdehof Sim</h2>
        
        <div style="border-bottom:1px solid #eee; margin-bottom:10px; padding-bottom:5px;">
            <strong>Dein Reiter</strong>
            <div class="row"><label>Haut</label><input type="color" id="skinColor" value="#ffdbac"></div>
            <div class="row"><label>Oberteil</label><input type="color" id="shirtColor" value="#e74c3c"></div>
            <div class="row"><label>Hose</label><input type="color" id="pantsColor" value="#34495e"></div>
        </div>

        <div style="margin-bottom:10px;">
            <strong>Dein Pferd</strong>
            <div class="row"><label>Fell</label><input type="color" id="horseColor" value="#5d4037"></div>
            <div class="row"><label>M√§hne</label><input type="color" id="maneColor" value="#1a1a1a"></div>
        </div>

        <button class="start-btn" id="startBtn">Hof betreten</button>
    </div>

    <div id="status-bar">Bereit</div>
    <div id="bubble">Wieherr!</div>
    
    <div id="minimap-container">
        <canvas id="minimap" width="200" height="200"></canvas>
    </div>

    <div id="controls-hint">
        <strong>Steuerung:</strong><br>
        WASD / Pfeile: Bewegen<br>
        [L]: Leine (Pferd muss nah sein)<br>
        [F]: F√ºttern (im Stall)<br>
        [1-3]: Tricks (auf Reitplatz)<br>
        Maus: Kamera drehen
    </div>

    <div id="feeding-modal">
        <h3>F√ºtterungszeit!</h3>
        <p>Das Pferd m√∂chte:</p>
        <div id="food-request">üçé</div>
        <p>W√§hle das richtige Futter:</p>
        <div>
            <button class="food-btn" onclick="feedHorse('üçé')">üçé</button>
            <button class="food-btn" onclick="feedHorse('ü•ï')">ü•ï</button>
            <button class="food-btn" onclick="feedHorse('üåæ')">üåæ</button>
        </div>
        <button onclick="closeFeedMenu()" style="margin-top:15px; padding:5px 15px; cursor:pointer;">Schlie√üen</button>
    </div>
</div>

<script>
    // --- THREE.JS VARIABLES ---
    let scene, camera, renderer;
    let player, horse, leashLine;
    let minimapCtx;
    
    // Game State
    let isLeashed = false;
    let gameState = "FREE"; 
    let horseState = "IDLE"; 
    let activeTaskTimer = 0;
    
    // Zones - Colors are for minimap
    const ZONES = {
        STABLE: { x: 30, z: -30, r: 10, color: "#8d6e63", label: "Stall" },
        ROUNDPEN: { x: -30, z: -30, r: 12, color: "#e6cea0", label: "Rondell" },
        PASTURE: { x: -30, z: 30, r: 18, color: "#7cb342", label: "Weide" },
        ARENA: { x: 30, z: 30, r: 15, color: "#f0e68c", label: "Reitplatz" }
    };

    // Camera & Input
    let cameraAngle = { phi: Math.PI/3.5, theta: Math.PI/4, dist: 12 };
    let keys = { w: false, s: false, a: false, d: false };
    let mouse = { x: 0, y: 0, down: false };
    let clock; // Initialized in init() to avoid reference error

    function init() {
        clock = new THREE.Clock(); // Correct place to initialize

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 20, 120);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 300);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(60, 100, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -80;
        dirLight.shadow.camera.right = 80;
        dirLight.shadow.camera.top = 80;
        dirLight.shadow.camera.bottom = -80;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);

        // Minimap
        const minimapCanvas = document.getElementById('minimap');
        minimapCtx = minimapCanvas.getContext('2d');

        createEnvironment();
        createPlayer();
        createHorse();
        createLeash();
        createClouds();

        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        window.addEventListener('mousedown', () => mouse.down = true);
        window.addEventListener('mouseup', () => mouse.down = false);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', onResize);

        animate();
    }

    // --- CREATION FUNCTIONS ---

    function createEnvironment() {
        // Soft Terrain
        const groundGeo = new THREE.PlaneGeometry(250, 250, 128, 128);
        const pos = groundGeo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            const x = pos.getX(i);
            const z = pos.getY(i);
            const h = Math.sin(x*0.04) * Math.cos(z*0.04) * 2 + 
                      Math.sin(x*0.1) * Math.cos(z*0.1) * 0.5;
            pos.setZ(i, h);
        }
        groundGeo.computeVertexNormals();
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x558b2f, 
            roughness: 1,
            flatShading: false
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // STABLE
        const stableGroup = new THREE.Group();
        const stableMat = new THREE.MeshStandardMaterial({color: 0x8d6e63});
        const roofMat = new THREE.MeshStandardMaterial({color: 0x5d4037});
        
        const postGeo = new THREE.CylinderGeometry(0.3, 0.3, 5, 8);
        [[-8,-8], [8,-8], [-8,8], [8,8]].forEach(p => {
            const post = new THREE.Mesh(postGeo, stableMat);
            post.position.set(p[0], 2.5, p[1]);
            post.castShadow = true;
            stableGroup.add(post);
        });
        const roofGeo = new THREE.ConeGeometry(14, 6, 4);
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.rotation.y = Math.PI/4;
        roof.position.y = 7;
        roof.castShadow = true;
        stableGroup.add(roof);
        
        const floor = new THREE.Mesh(new THREE.CylinderGeometry(12, 12, 0.2, 32), new THREE.MeshStandardMaterial({color:0x6d4c41}));
        floor.position.y = 0.1;
        stableGroup.add(floor);
        
        stableGroup.position.set(ZONES.STABLE.x, 0, ZONES.STABLE.z);
        scene.add(stableGroup);

        // ROUNDPEN
        const sandMat = new THREE.MeshStandardMaterial({ color: 0xe6cea0, roughness: 1 });
        const penFloor = new THREE.Mesh(new THREE.CylinderGeometry(ZONES.ROUNDPEN.r, ZONES.ROUNDPEN.r, 0.1, 32), sandMat);
        penFloor.position.set(ZONES.ROUNDPEN.x, 0.1, ZONES.ROUNDPEN.z);
        penFloor.receiveShadow = true;
        scene.add(penFloor);
        createCurvedFence(ZONES.ROUNDPEN.x, ZONES.ROUNDPEN.z, ZONES.ROUNDPEN.r);

        // PASTURE
        createFenceRect(ZONES.PASTURE.x, ZONES.PASTURE.z, 30, 30);
        for(let i=0; i<60; i++) {
            createFlower(ZONES.PASTURE.x + (Math.random()-0.5)*25, ZONES.PASTURE.z + (Math.random()-0.5)*25);
        }

        // ARENA
        const arenaFloor = new THREE.Mesh(new THREE.BoxGeometry(34, 0.1, 34), sandMat);
        arenaFloor.position.set(ZONES.ARENA.x, 0.1, ZONES.ARENA.z);
        arenaFloor.receiveShadow = true;
        scene.add(arenaFloor);
        createFenceRect(ZONES.ARENA.x, ZONES.ARENA.z, 34, 34, true);

        // NATURE
        for(let i=0; i<60; i++) {
            const x = (Math.random()-0.5) * 200;
            const z = (Math.random()-0.5) * 200;
            if(Math.abs(x) < 50 && Math.abs(z) < 50) continue;
            createDetailedTree(x, z);
        }
        for(let i=0; i<30; i++) {
            createDetailedRock((Math.random()-0.5)*220, (Math.random()-0.5)*220);
        }
    }

    function createCurvedFence(cx, cz, r) {
        const count = 30;
        const woodMat = new THREE.MeshStandardMaterial({color: 0x8d6e63});
        for(let i=0; i<count; i++) {
            const theta = (i/count) * Math.PI * 2;
            const x = cx + Math.cos(theta) * r;
            const z = cz + Math.sin(theta) * r;
            
            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.8, 8), woodMat);
            post.position.set(x, 0.9, z);
            post.castShadow = true;
            scene.add(post);

            if(i < count) {
                const nextTheta = ((i+1)/count) * Math.PI * 2;
                const nx = cx + Math.cos(nextTheta) * r;
                const nz = cz + Math.sin(nextTheta) * r;
                
                const midX = (x + nx)/2;
                const midZ = (z + nz)/2;
                const dist = Math.hypot(nx-x, nz-z);
                const angle = Math.atan2(nz-z, nx-x);
                
                const rail = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, dist, 6), new THREE.MeshStandardMaterial({color: 0xffffff}));
                rail.rotation.z = Math.PI/2;
                rail.rotation.y = -angle;
                rail.position.set(midX, 1.4, midZ);
                scene.add(rail);
            }
        }
    }

    function createFenceRect(cx, cz, w, h, isLow = false) {
        const height = isLow ? 1.0 : 1.5;
        const postMat = new THREE.MeshStandardMaterial({color: 0xffffff});
        
        const corners = [
            {x: cx - w/2, z: cz - h/2}, {x: cx + w/2, z: cz - h/2},
            {x: cx - w/2, z: cz + h/2}, {x: cx + w/2, z: cz + h/2},
            {x: cx, z: cz - h/2}, {x: cx, z: cz + h/2},
            {x: cx - w/2, z: cz}, {x: cx + w/2, z: cz}
        ];
        
        corners.forEach(p => {
            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, height, 12), postMat);
            post.position.set(p.x, height/2, p.z);
            post.castShadow = true;
            scene.add(post);
        });

        const railMat = new THREE.MeshStandardMaterial({color: 0xffffff});
        const railT = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, w, 8), railMat);
        railT.rotation.z = Math.PI/2; railT.position.set(cx, height-0.2, cz - h/2); scene.add(railT);
        
        const railB = railT.clone(); railB.position.z = cz + h/2; scene.add(railB);
        
        const railL = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, h, 8), railMat);
        railL.rotation.x = Math.PI/2; railL.position.set(cx - w/2, height-0.2, cz); scene.add(railL);
        
        const railR = railL.clone(); railR.position.x = cx + w/2; scene.add(railR);
    }

    function createDetailedTree(x, z) {
        const group = new THREE.Group();
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 2.5, 8);
        const trunkMat = new THREE.MeshStandardMaterial({color: 0x4e342e});
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1.25;
        trunk.castShadow = true;
        group.add(trunk);

        const leavesMat = new THREE.MeshStandardMaterial({color: 0x2e7d32, flatShading: false});
        const positions = [[0, 3.5, 0], [1, 2.8, 0], [-1, 2.8, 0.5], [0, 2.8, -1], [0.5, 4.2, 0]];
        positions.forEach(p => {
            const size = 1 + Math.random();
            const leaf = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), leavesMat);
            leaf.position.set(p[0]*0.8, p[1], p[2]*0.8);
            leaf.castShadow = true;
            group.add(leaf);
        });

        const s = 1 + Math.random() * 0.5;
        group.scale.set(s,s,s);
        group.position.set(x, 0, z);
        group.rotation.y = Math.random() * Math.PI;
        scene.add(group);
    }

    function createDetailedRock(x, z) {
        const geo = new THREE.SphereGeometry(1, 4, 3);
        const mat = new THREE.MeshStandardMaterial({color: 0x808080, roughness: 0.9});
        const rock = new THREE.Mesh(geo, mat);
        rock.position.set(x, 0.3, z);
        rock.scale.set(0.5 + Math.random(), 0.3 + Math.random()*0.3, 0.5 + Math.random());
        rock.castShadow = true;
        scene.add(rock);
    }

    function createFlower(x, z) {
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.4), new THREE.MeshBasicMaterial({color: 0x00ff00}));
        stem.position.set(x, 0.2, z);
        scene.add(stem);
        const petalColor = Math.random() > 0.5 ? 0xffeb3b : 0xe91e63;
        const flower = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), new THREE.MeshBasicMaterial({color: petalColor}));
        flower.position.set(x, 0.4, z);
        flower.scale.y = 0.5;
        scene.add(flower);
    }

    function createClouds() {
        const cloudGeo = new THREE.SphereGeometry(2, 16, 16);
        const cloudMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.9});
        for(let i=0; i<12; i++) {
            const group = new THREE.Group();
            for(let j=0; j<5; j++) {
                const p = new THREE.Mesh(cloudGeo, cloudMat);
                p.position.set((Math.random()-0.5)*5, (Math.random()-0.5)*1.5, (Math.random()-0.5)*3);
                p.scale.set(1 + Math.random(), 0.8, 1);
                group.add(p);
            }
            group.position.set((Math.random()-0.5)*250, 35 + Math.random()*15, (Math.random()-0.5)*250);
            scene.add(group);
        }
    }

    // --- CHARACTERS (Rounded) ---

    function createPlayer() {
        player = new THREE.Group();
        const skinMat = new THREE.MeshStandardMaterial({color: 0xffdbac});
        const shirtMat = new THREE.MeshStandardMaterial({color: 0xe74c3c});
        const pantsMat = new THREE.MeshStandardMaterial({color: 0x34495e});

        // Torso
        const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.2, 0.6, 16), shirtMat);
        torso.position.y = 1.3; torso.name = "shirt"; torso.castShadow=true;
        player.add(torso);

        // Head
        const headGroup = new THREE.Group();
        headGroup.position.y = 1.8;
        const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 16), skinMat);
        headMesh.name = "skin"; headMesh.castShadow=true;
        headGroup.add(headMesh);
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(0.04);
        const eyeMat = new THREE.MeshBasicMaterial({color:0x000000});
        const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.08, 0.05, 0.18); headGroup.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.08, 0.05, 0.18); headGroup.add(eyeR);
        
        player.add(headGroup);

        // Arms
        const armGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.5, 8);
        const armL = new THREE.Mesh(armGeo, shirtMat); armL.position.set(-0.32, 1.4, 0); armL.name="shirt"; armL.castShadow=true; armL.rotation.z = 0.2;
        const armR = new THREE.Mesh(armGeo, shirtMat); armR.position.set(0.32, 1.4, 0); armR.name="shirt"; armR.castShadow=true; armR.rotation.z = -0.2;
        player.add(armL); player.add(armR);

        // Legs
        const legGeo = new THREE.CylinderGeometry(0.09, 0.08, 0.75, 8);
        const legL = new THREE.Mesh(legGeo, pantsMat); legL.position.set(-0.12, 0.65, 0); legL.name = "pants"; legL.castShadow=true;
        const legLGroup = new THREE.Group(); legLGroup.add(legL); legL.position.y = -0.375; legLGroup.position.set(-0.12, 1.0, 0);
        player.add(legLGroup); player.legL = legLGroup;

        const legR = new THREE.Mesh(legGeo, pantsMat); legR.position.set(0.12, 0.65, 0); legR.name = "pants"; legR.castShadow=true;
        const legRGroup = new THREE.Group(); legRGroup.add(legR); legR.position.y = -0.375; legRGroup.position.set(0.12, 1.0, 0);
        player.add(legRGroup); player.legR = legRGroup;

        player.position.set(0, 0, 10);
        scene.add(player);
    }

    function createHorse() {
        horse = new THREE.Group();
        const furMat = new THREE.MeshStandardMaterial({color: 0x5d4037});
        const maneMat = new THREE.MeshStandardMaterial({color: 0x111111});
        const hoofMat = new THREE.MeshStandardMaterial({color: 0x111111});

        // Body
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.55, 1.6, 16), furMat);
        body.rotation.x = Math.PI/2;
        body.position.y = 1.25; body.name = "fur"; body.castShadow=true;
        horse.add(body);

        // Neck
        const neckGroup = new THREE.Group();
        neckGroup.position.set(0, 1.5, 0.7);
        const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 0.9, 12), furMat);
        neck.position.set(0, 0.4, 0); neck.rotation.x = -0.4; neck.name="fur"; neck.castShadow=true;
        neckGroup.add(neck);

        // Head
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 0.8, 0.3); 
        headGroup.rotation.x = 0.4;
        
        const headMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.7, 12), furMat);
        headMesh.rotation.x = Math.PI/2;
        headMesh.name="fur"; headMesh.castShadow=true;
        headGroup.add(headMesh);

        // Ears
        const earGeo = new THREE.ConeGeometry(0.06, 0.2, 8);
        const earL = new THREE.Mesh(earGeo, furMat); earL.position.set(-0.12, 0.3, -0.2); earL.name="fur"; headGroup.add(earL);
        const earR = new THREE.Mesh(earGeo, furMat); earR.position.set(0.12, 0.3, -0.2); earR.name="fur"; headGroup.add(earR);

        neckGroup.add(headGroup);

        // Mane
        const mane = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.15), maneMat);
        mane.position.set(0, 0.5, -0.2); mane.rotation.x = -0.4; mane.name="mane";
        neckGroup.add(mane);

        horse.add(neckGroup);
        horse.neck = neckGroup;

        // Tail
        const tailGroup = new THREE.Group();
        tailGroup.position.set(0, 1.4, -0.8);
        const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.15, 0.9, 8), maneMat);
        tail.position.y = -0.4;
        tail.rotation.x = 0.3; tail.name="mane";
        tailGroup.add(tail);
        horse.add(tailGroup);
        horse.tail = tailGroup;

        // Legs
        function createLeg(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 1.0, z);
            const l = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 1.0, 8), furMat);
            l.position.y = -0.5; l.name = "fur"; l.castShadow=true;
            const h = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.12, 0.15, 8), hoofMat);
            h.position.y = -1.0; h.castShadow=true;
            g.add(l); g.add(h);
            return g;
        }

        horse.legFL = createLeg(0.25, 0.6); horse.add(horse.legFL);
        horse.legFR = createLeg(-0.25, 0.6); horse.add(horse.legFR);
        horse.legBL = createLeg(0.25, -0.6); horse.add(horse.legBL);
        horse.legBR = createLeg(-0.25, -0.6); horse.add(horse.legBR);

        horse.position.set(ZONES.STABLE.x - 5, 0, ZONES.STABLE.z + 5);
        scene.add(horse);
    }

    function createLeash() {
        const mat = new THREE.LineBasicMaterial({ color: 0x222222, linewidth: 2 });
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
        leashLine = new THREE.Line(geo, mat);
        leashLine.visible = false;
        leashLine.frustumCulled = false;
        scene.add(leashLine);
    }

    // --- GAME LOGIC ---

    function updatePhysics(dt) {
        if(gameState !== "FREE") return;

        const speed = 7.0 * dt;
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

        const moveDir = new THREE.Vector3();
        if(keys.w) moveDir.add(forward);
        if(keys.s) moveDir.sub(forward);
        if(keys.a) moveDir.add(right);
        if(keys.d) moveDir.sub(right);

        let isMoving = false;
        if(moveDir.lengthSq() > 0) {
            isMoving = true;
            moveDir.normalize();
            player.position.addScaledVector(moveDir, speed);
            const targetRot = Math.atan2(moveDir.x, moveDir.z);
            let rotDiff = targetRot - player.rotation.y;
            while(rotDiff > Math.PI) rotDiff -= Math.PI*2;
            while(rotDiff < -Math.PI) rotDiff += Math.PI*2;
            player.rotation.y += rotDiff * 0.2;
        }

        if(isMoving) {
            const time = Date.now() * 0.015;
            player.legL.rotation.x = Math.sin(time) * 0.8;
            player.legR.rotation.x = Math.sin(time + Math.PI) * 0.8;
            player.children.forEach(c => { // Bob body
                if(c.name === 'shirt' && c.geometry.type === 'CylinderGeometry') c.position.y = 1.3 + Math.sin(time*2)*0.05;
            });
        } else {
            player.legL.rotation.x = THREE.MathUtils.lerp(player.legL.rotation.x, 0, 0.2);
            player.legR.rotation.x = THREE.MathUtils.lerp(player.legR.rotation.x, 0, 0.2);
        }

        if(isLeashed) {
            horseState = "FOLLOWING";
            updateLeashPhysics(dt);
        } else {
            checkZones();
            if(horseState === "ROUNDPEN") runRoundpen(dt);
            else if(horseState === "GRAZING") updateGrazing(dt);
            else if(horseState === "GROUNDWORK") resetHorsePose(0.1);
            else { horseState = "IDLE"; resetHorsePose(0.05); }
        }
        
        updateStatusBar();
    }

    function updateLeashPhysics(dt) {
        const dist = player.position.distanceTo(horse.position);
        if(dist > 2.8) {
            const dir = new THREE.Vector3().subVectors(player.position, horse.position).normalize();
            dir.y = 0;
            horse.position.addScaledVector(dir, 6.0 * dt);
            const targetRot = Math.atan2(dir.x, dir.z);
            let rotDiff = targetRot - horse.rotation.y;
            while(rotDiff > Math.PI) rotDiff -= Math.PI*2;
            while(rotDiff < -Math.PI) rotDiff += Math.PI*2;
            horse.rotation.y += rotDiff * 0.1;
            animateHorseWalk(true);
        } else {
            animateHorseWalk(false);
        }
        updateLeashVisual();
    }

    function updateLeashVisual() {
        const handPos = player.position.clone(); handPos.y = 1.3;
        // Offset hand to side
        handPos.add(new THREE.Vector3(0.3, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y));
        
        const neckPos = horse.position.clone(); neckPos.y = 1.5; 
        neckPos.add(new THREE.Vector3(0,0,0.7).applyAxisAngle(new THREE.Vector3(0,1,0), horse.rotation.y));
        
        const posAttr = leashLine.geometry.attributes.position;
        posAttr.setXYZ(0, handPos.x, handPos.y, handPos.z);
        posAttr.setXYZ(1, neckPos.x, neckPos.y, neckPos.z);
        posAttr.needsUpdate = true;
        leashLine.visible = true;
    }

    function checkZones() {
        const p = horse.position;
        if(dist(p.x, p.z, ZONES.ROUNDPEN.x, ZONES.ROUNDPEN.z) < ZONES.ROUNDPEN.r) {
            if(horseState !== "ROUNDPEN") { horseState = "ROUNDPEN"; activeTaskTimer = 0; showBubble("Bereit zum Laufen!"); }
            return;
        }
        if(p.x > ZONES.PASTURE.x - 14 && p.x < ZONES.PASTURE.x + 14 && 
           p.z > ZONES.PASTURE.z - 14 && p.z < ZONES.PASTURE.z + 14) {
            if(horseState !== "GRAZING") { horseState = "GRAZING"; activeTaskTimer = 0; }
            return;
        }
        if(p.x > ZONES.ARENA.x - 12 && p.x < ZONES.ARENA.x + 12 && 
           p.z > ZONES.ARENA.z - 12 && p.z < ZONES.ARENA.z + 12) {
            horseState = "GROUNDWORK";
            return;
        }
    }

    function runRoundpen(dt) {
        activeTaskTimer += dt;
        const radius = 9;
        const center = new THREE.Vector3(ZONES.ROUNDPEN.x, 0, ZONES.ROUNDPEN.z);
        if(activeTaskTimer < 12) {
            const speed = 1.5;
            const angle = Date.now() * 0.001 * speed;
            horse.position.set(center.x + Math.cos(angle)*radius, 0, center.z + Math.sin(angle)*radius);
            horse.lookAt(center.x + Math.cos(angle+0.5)*radius, 0, center.z + Math.sin(angle+0.5)*radius);
            animateHorseWalk(true, 2.0);
        } else {
            resetHorsePose();
            if(activeTaskTimer < 12.1) showBubble("Wieherr! (Fertig)");
            horse.lookAt(player.position.x, 0, player.position.z);
        }
    }

    function updateGrazing(dt) {
        activeTaskTimer += dt;
        horse.neck.rotation.x = THREE.MathUtils.lerp(horse.neck.rotation.x, 0.7, 0.05);
        if(activeTaskTimer > 8 && activeTaskTimer < 8.1) showBubble("Munch Munch...");
        if(activeTaskTimer > 15 && activeTaskTimer < 15.1) showBubble("Wieherr! (Satt)");
        horse.tail.rotation.z = Math.sin(Date.now() * 0.003) * 0.3; // Lazy tail swish
    }

    function animateHorseWalk(isMoving, speedMult = 1.0) {
        if(isMoving) {
            const time = Date.now() * 0.01 * speedMult;
            horse.legFL.rotation.x = Math.sin(time) * 0.6;
            horse.legBR.rotation.x = Math.sin(time) * 0.6;
            horse.legFR.rotation.x = Math.sin(time + Math.PI) * 0.6;
            horse.legBL.rotation.x = Math.sin(time + Math.PI) * 0.6;
            horse.neck.rotation.x = -0.4 + Math.sin(time * 2) * 0.05;
            horse.tail.rotation.z = Math.sin(time * 1.5) * 0.15;
            horse.position.y = 1.25 + Math.sin(time*2)*0.05; // Gallop bounce
        } else {
            resetHorsePose();
        }
    }

    function resetHorsePose(lerp = 0.1) {
        horse.legFL.rotation.x = THREE.MathUtils.lerp(horse.legFL.rotation.x, 0, lerp);
        horse.legFR.rotation.x = THREE.MathUtils.lerp(horse.legFR.rotation.x, 0, lerp);
        horse.legBL.rotation.x = THREE.MathUtils.lerp(horse.legBL.rotation.x, 0, lerp);
        horse.legBR.rotation.x = THREE.MathUtils.lerp(horse.legBR.rotation.x, 0, lerp);
        horse.neck.rotation.x = THREE.MathUtils.lerp(horse.neck.rotation.x, -0.4, lerp);
        horse.rotation.z = THREE.MathUtils.lerp(horse.rotation.z, 0, lerp);
        horse.position.y = THREE.MathUtils.lerp(horse.position.y, 1.25, lerp);
        horse.tail.rotation.z = THREE.MathUtils.lerp(horse.tail.rotation.z, 0, lerp);
    }

    // --- MINIMAP LABELS ---
    function drawMinimap() {
        if(!minimapCtx) return;
        const width = 200, height = 200;
        const range = 140; 
        
        // Clear
        minimapCtx.fillStyle = "rgba(0,0,0,0.85)";
        minimapCtx.fillRect(0, 0, width, height);

        const mapX = (x) => (x / range) * width + width/2;
        const mapZ = (z) => (z / range) * height + height/2;
        const mapScale = (v) => (v / range) * width;

        // Draw Zones
        minimapCtx.font = "12px sans-serif";
        minimapCtx.textAlign = "center";
        minimapCtx.textBaseline = "middle";

        for(const k in ZONES) {
            const z = ZONES[k];
            minimapCtx.fillStyle = z.color;
            minimapCtx.beginPath();
            if(k === "ROUNDPEN" || k === "STABLE") {
                minimapCtx.arc(mapX(z.x), mapZ(z.z), mapScale(z.r), 0, Math.PI*2);
            } else {
                minimapCtx.rect(mapX(z.x - z.r), mapZ(z.z - z.r), mapScale(z.r*2), mapScale(z.r*2));
            }
            minimapCtx.fill();

            // Label
            minimapCtx.fillStyle = "white";
            minimapCtx.strokeStyle = "black";
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeText(z.label, mapX(z.x), mapZ(z.z));
            minimapCtx.fillText(z.label, mapX(z.x), mapZ(z.z));
        }

        // Draw Horse
        minimapCtx.fillStyle = "#ff9800"; 
        minimapCtx.beginPath();
        minimapCtx.arc(mapX(horse.position.x), mapZ(horse.position.z), 5, 0, Math.PI*2);
        minimapCtx.fill();

        // Draw Player
        minimapCtx.fillStyle = "#00bcd4";
        minimapCtx.beginPath();
        minimapCtx.arc(mapX(player.position.x), mapZ(player.position.z), 5, 0, Math.PI*2);
        minimapCtx.fill();

        // View Cone
        const fwd = new THREE.Vector3();
        camera.getWorldDirection(fwd);
        minimapCtx.strokeStyle = "rgba(255,255,255,0.5)";
        minimapCtx.beginPath();
        minimapCtx.moveTo(mapX(player.position.x), mapZ(player.position.z));
        minimapCtx.lineTo(mapX(player.position.x + fwd.x * 20), mapZ(player.position.z + fwd.z * 20));
        minimapCtx.stroke();
    }

    // --- INPUTS & UI ---

    function onKeyDown(e) {
        const key = e.key.toLowerCase();
        if(['w','arrowup'].includes(key)) keys.w = true;
        if(['s','arrowdown'].includes(key)) keys.s = true;
        if(['a','arrowleft'].includes(key)) keys.a = true;
        if(['d','arrowright'].includes(key)) keys.d = true;
        
        if(key === 'l') toggleLeash();
        if(key === 'f') tryFeed();
        
        if(horseState === "GROUNDWORK") {
            if(key === '1') doTrick("REAR");
            if(key === '2') doTrick("BOW");
            if(key === '3') doTrick("SPIN");
        }
    }
    function onKeyUp(e) {
        const key = e.key.toLowerCase();
        if(['w','arrowup'].includes(key)) keys.w = false;
        if(['s','arrowdown'].includes(key)) keys.s = false;
        if(['a','arrowleft'].includes(key)) keys.a = false;
        if(['d','arrowright'].includes(key)) keys.d = false;
    }

    function toggleLeash() {
        if(isLeashed) {
            isLeashed = false; leashLine.visible = false; activeTaskTimer = 0; showBubble("Losgelassen");
        } else {
            if(player.position.distanceTo(horse.position) < 4) { isLeashed = true; horseState = "FOLLOWING"; showBubble("Angeleint"); }
            else showBubble("Zu weit weg!");
        }
    }

    function doTrick(type) {
        if(type === "REAR") {
            const tl = setInterval(() => { horse.rotation.x = -0.8; horse.position.y = 2.0; }, 10);
            setTimeout(() => { clearInterval(tl); resetHorsePose(1.0); }, 1000); showBubble("Steigen!");
        }
        if(type === "BOW") {
            const tl = setInterval(() => { horse.rotation.z = 0.2; horse.rotation.x = 0.6; horse.position.y = 0.5; }, 10);
            setTimeout(() => { clearInterval(tl); resetHorsePose(1.0); }, 1500); showBubble("Verbeugen!");
        }
        if(type === "SPIN") {
            let r = 0;
            const tl = setInterval(() => { horse.rotation.y += 0.2; r++; if(r>30) clearInterval(tl); }, 16);
            showBubble("Drehen!");
        }
    }

    let requestedFood = "";
    const FOODS = ['üçé', 'ü•ï', 'üåæ'];

    function tryFeed() {
        if(dist(player.position.x, player.position.z, ZONES.STABLE.x, ZONES.STABLE.z) < ZONES.STABLE.r) {
            if(player.position.distanceTo(horse.position) < 6) {
                gameState = "FEEDING";
                requestedFood = FOODS[Math.floor(Math.random()*FOODS.length)];
                document.getElementById('food-request').innerText = requestedFood;
                document.getElementById('feeding-modal').style.display = 'block';
                keys = {w:false, s:false, a:false, d:false};
            } else showBubble("Pferd herholen!");
        } else showBubble("Geh in den Stall!");
    }

    window.feedHorse = function(item) {
        if(item === requestedFood) showBubble("Lecker! ‚ô•");
        else showBubble("P√ºh! (Falsch)");
        closeFeedMenu();
    };
    window.closeFeedMenu = function() {
        document.getElementById('feeding-modal').style.display = 'none';
        gameState = "FREE";
    };

    function onMouseMove(e) {
        if(mouse.down && gameState === "FREE") {
            cameraAngle.theta -= e.movementX * 0.005;
            cameraAngle.phi -= e.movementY * 0.005;
            cameraAngle.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, cameraAngle.phi));
        }
    }
    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function updateCamera() {
        const target = player.position.clone().add(new THREE.Vector3(0, 2, 0));
        const offset = new THREE.Vector3(
            cameraAngle.dist * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta),
            cameraAngle.dist * Math.cos(cameraAngle.phi),
            cameraAngle.dist * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta)
        );
        camera.position.copy(target).add(offset);
        camera.lookAt(target);
    }

    function animate() {
        requestAnimationFrame(animate);
        // Safety check if clock is initialized
        if(clock) {
            const dt = clock.getDelta();
            if(gameState === "FREE") updatePhysics(dt);
        }
        drawMinimap();
        updateCamera();
        renderer.render(scene, camera);
    }

    function dist(x1, z1, x2, z2) { return Math.sqrt((x2-x1)**2 + (z2-z1)**2); }
    function showBubble(text) {
        const b = document.getElementById('bubble');
        b.innerText = text; b.style.display = 'block';
        setTimeout(() => b.style.display = 'none', 2000);
    }
    function updateStatusBar() {
        const sb = document.getElementById('status-bar'); sb.style.display = 'block';
        if(isLeashed) sb.innerText = "Spaziergang";
        else if(horseState === "ROUNDPEN") sb.innerText = "Training: " + Math.min(100, Math.floor(activeTaskTimer * 10)) + "%";
        else if(horseState === "GRAZING") sb.innerText = "Grasen...";
        else if(horseState === "GROUNDWORK") sb.innerText = "Bodenarbeit (1, 2, 3)";
        else sb.innerText = "Freizeit";
    }

    document.getElementById('startBtn').onclick = () => {
        updateColors();
        document.getElementById('config-panel').style.display = 'none';
    };
    function updateColors() {
        const pSkin = document.getElementById('skinColor').value;
        const pShirt = document.getElementById('shirtColor').value;
        const pPants = document.getElementById('pantsColor').value;
        player.traverse(o => {
            if(o.name==="skin") o.material.color.set(pSkin);
            if(o.name==="shirt") o.material.color.set(pShirt);
            if(o.name==="pants") o.material.color.set(pPants);
        });
        const hFur = document.getElementById('horseColor').value;
        const hMane = document.getElementById('maneColor').value;
        horse.traverse(o => {
            if(o.name==="fur") o.material.color.set(hFur);
            if(o.name==="mane") o.material.color.set(hMane);
        });
    }

    window.onload = init;
</script>
</body>
</html>